<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Vanadium</title>
    <link>https://v.io/tutorials/</link>
    <description>Recent content in Tutorials on Vanadium</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://v.io/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fortune in Java</title>
      <link>https://v.io/tutorials/java/fortune/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/java/fortune/</guid>
      <description>Introduction In this tutorial, we will create a fortune teller server and a client to talk to it. The server will have two methods:
 Add, which adds a fortune to the list of fortunes, and Get, which retrieves a random fortune.  Setting up the project In this tutorial, we will use the Gradle build tool to build the project. There is no requirement that Vanadium Java projects use Gradle, but it&amp;rsquo;s the easiest way to get started.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://v.io/tutorials/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/java/</guid>
      <description>Vanadium supports writing secure and distributed applications in Java.
By using the Vanadium Definition Language (VDL), Vanadium apps written in Java can also communicate with Vanadium servers and clients written in other languages.
Unlike other tutorials, the Java tutorials do not require a Vanadium installation.
  Fortune in Java
Wherein you build a fortune teller service and a client to talk to it.
  Location Service in Android</description>
    </item>
    
    <item>
      <title>Location Service in Android</title>
      <link>https://v.io/tutorials/java/android/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/java/android/</guid>
      <description>Introduction In this tutorial, we will build a very simple Android application that will create a Vanadium server on the phone. When queried by an authorized client, the server will return the phone&amp;rsquo;s physical location (latitude and longitude).
The tutorial will demonstrate some Android-specific aspects of the Vanadium implementation. It will also show that Vanadium allows clients to work across NAT networks transparently.
We will be building three software components in this tutorial:</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://v.io/tutorials/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/hello-world/</guid>
      <description>Introduction Practically speaking, Vanadium is a set of Go and Java language libraries (more languages coming), plus a few dozen services and command line tools built on top of them.
The goal of this first tutorial is to get you to running code as quickly as possible. Subsequent tutorials will explain what&amp;rsquo;s happening here in more detail, and take you much further into security and service discovery.
When they do so, the tutorials create files in $V_TUT (likely $HOME/v23_tutorial):</description>
    </item>
    
    <item>
      <title>Client/Server Basics</title>
      <link>https://v.io/tutorials/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/basics/</guid>
      <description>Introduction In the hello world tutorial, you got a client and server running.
In this tutorial, you&amp;rsquo;ll build a slightly more complex client and server that will serve as the framework for deeper explorations of Vanadium security and service discovery.
This time, the server code is split into multiple files. The new code structure lets later tutorials change only the parts that need to change (e.g., a dispatcher, an authorizer), keeping later code shorter and clearer.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://v.io/tutorials/security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/</guid>
      <description>In Vanadium, all communication channels are encrypted and authenticated, and all communication must satisfy an authorization policy.
The following tutorials build from the Client/Server Basics tutorial to demonstrate code and pre-built tools that implement and benefit from Vanadium security.
  Principals and Blessings
Wherein Alice and her friend Bob take the stage to demonstrate inter-principal communication.
  Permissions
Wherein you meet a built-in authorizer that that lets Alice grant fine-grained access to Bob and Carol with simple lists of names.</description>
    </item>
    
    <item>
      <title>Principals and Blessings</title>
      <link>https://v.io/tutorials/security/principals-and-blessings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/principals-and-blessings/</guid>
      <description>Principals A principal in the Vanadium framework is simply a public and private key pair. It has a set of human-readable names bound to it using public-key certificate chains, called blessings. All Vanadium processes act on behalf of a principal and are authorized by other processes based on the blessing names bound to the principal.
For example a principal Alice may have the blessings alice and bob:houseguest bound to it. A process running on behalf of Alice may authenticate to others as either alice or bob:houseguest or both.</description>
    </item>
    
    <item>
      <title>Permissions Authorizer</title>
      <link>https://v.io/tutorials/security/permissions-authorizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/permissions-authorizer/</guid>
      <description>Permissions policy In addition to the default authorization policy, Vanadium offers another built-in authorization policy based on the commonly used idea of a permissions map. Such an authorizer allows a wide range of policies controllable via editing lists that are given to a server as flags - no need to modify code.
{{# helpers.info }}
Vanadium also supports the use of a completely custom policy - the procedure for building one is covered in the custom authorizer tutorial.</description>
    </item>
    
    <item>
      <title>Caveats</title>
      <link>https://v.io/tutorials/security/first-party-caveats/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/first-party-caveats/</guid>
      <description>Start server with permissions This tutorial uses the server with the Permissions authorizer (described in the permissions-authorizer tutorial):
kill_tut_process TUT_PID_SERVER $V_TUT/bin/server \ --v23.credentials $V_TUT/cred/alice \ --endpoint-file-name $V_TUT/server.txt \ --perms &#39;{&amp;quot;R&amp;quot;: {&amp;quot;In&amp;quot;: [&amp;quot;alice:family&amp;quot;, &amp;quot;alice:friend&amp;quot;]}, &amp;quot;W&amp;quot;: {&amp;quot;In&amp;quot;: [&amp;quot;alice:family&amp;quot;]}}&#39; &amp;amp; TUT_PID_SERVER=$! Blessings as delegation Blessings bind human-readable names (e.g., alice:friend:bob) to a principal (identified by its public key). Principals are authorized based on these names. For instance, permissions provide a means of specifying authorization policy using a list of patterns that match these names.</description>
    </item>
    
    <item>
      <title>Third-party Caveats</title>
      <link>https://v.io/tutorials/security/third-party-caveats/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/third-party-caveats/</guid>
      <description>Introduction Earlier you learned how to add caveats to a blessing to restrict its validity. For example, one can make a blessing expire after a few minutes, or restrict it to work only when accessing a particular method on a service. These conditions are validated by the server before allowing the client to invoke a method.
This tutorial introduces third-party caveats. The restrictions encoded in the caveat are validated by a third party that issues a proof of validity called a discharge.</description>
    </item>
    
    <item>
      <title>The Agent</title>
      <link>https://v.io/tutorials/security/agent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/agent/</guid>
      <description>Motivation In the principals tutorial you used the principal create command to create the principals Alice, Bob, etc. The operation made collections of files in the specified target directories, e.g.:
ls $V_TUT/cred/alice $V_TUT/cred/bob Stored among these files are the private keys associated with Alice and Bob. The keys could be encrypted (there are ways to do that), but at the moment, they aren&amp;rsquo;t. At no point during earlier tutorials did you - the tutee - get prompted for a passphrase, despite frequent use of the --v23.</description>
    </item>
    
    <item>
      <title>Custom Authorizer</title>
      <link>https://v.io/tutorials/security/custom-authorizer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/security/custom-authorizer/</guid>
      <description>Introduction The goal of this tutorial is to make a custom authorizer and test it using some existing principals.
This command
ls $V_TUT/cred should list (at least) alice and bob and carol.
The prerequisite script should have arranged for Bob to have the blessing alice:friend:bob and Carol to have the blessing alice:family:sister.
Custom authorization policy If the Permissions authorizer and/or caveats (caveats are discussed later) aren&amp;rsquo;t sufficient for some purpose, Vanadium applications can create their own arbitrarily complex policy by implementing the security.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://v.io/tutorials/naming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/</guid>
      <description>Naming, like security, is central to Vanadium.
Naming is Vanadium&amp;rsquo;s term for service identification and discovery.
The following tutorials build from the basics tutorial to demonstrate code and pre-built tools that implement and benefit from Vanadium naming.
  The Mount Table
Wherein you use the basic tools of service discovery.
  Namespaces
Wherein you manipulate multiple mount tables to create a rich namespace.
  The Suffix - Part I</description>
    </item>
    
    <item>
      <title>The Mount Table</title>
      <link>https://v.io/tutorials/naming/mount-table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/mount-table/</guid>
      <description>Introduction This tutorial focusses on using a mount table with the fortune server and client programs you made in the basics tutorial, and just re-made with the prerequisites script above.
Credentials To keep security simple initially, all processes here will use the same credentials. Further, credentials will be specified using this environment variable:
export V23_CREDENTIALS=$V_TUT/cred/basics Vanadium programs consult this environment variable when the credentials aren&amp;rsquo;t specified by using the --v23.credentials flag, or by using a security agent.</description>
    </item>
    
    <item>
      <title>Namespaces</title>
      <link>https://v.io/tutorials/naming/namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/namespace/</guid>
      <description>Introduction As done in the mount table tutorial, this tutorial will use just one set of credentials for all processes:
export V23_CREDENTIALS=$V_TUT/cred/basics This tutorial will use three distinct mount table servers, named HOME, METERS and UTILITY. These names are in uppercase to distinguish them from service names used in table entries, where we&amp;rsquo;ll stick with a lowercase convention.
Start HOME first:
PORT_MT_HOME=23000 # Pick an unused port. kill_tut_process TUT_PID_MT_HOME $V_BIN/mounttabled --v23.</description>
    </item>
    
    <item>
      <title>The Suffix - Part I</title>
      <link>https://v.io/tutorials/naming/suffix-part1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/suffix-part1/</guid>
      <description>Introduction In an earlier tutorial, a fortune server was mounted in a table with the name fortuneAlpha.
Since that server contained only one service, clients needed nothing more than that name, as seen in the mount table, to start using the service.
If a server contains multiple services, a suffix is needed to select one. A mount table doesn&amp;rsquo;t know about suffixes directly. A server encapsulates that knowledge in its dispatcher.</description>
    </item>
    
    <item>
      <title>The Suffix - Part II</title>
      <link>https://v.io/tutorials/naming/suffix-part2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/suffix-part2/</guid>
      <description>Introduction In the suffix Part I, you built a fortune server with multiple services. For simplicity, this server used the default authorizer and only allowed calls from the same principal.
In Part II, you will learn how to implement a fine-grained access control policy for your services.
Let&amp;rsquo;s add some requirements to our Part I example.
Requirements Your company, Prophecies Inc, needs a server to support its team of prophetic consultants - Cassandra, Nostradamus, etc.</description>
    </item>
    
    <item>
      <title>Globber</title>
      <link>https://v.io/tutorials/naming/globber/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/naming/globber/</guid>
      <description>Introduction In the suffix Part I and Part II tutorials, we introduced the concept of server namespace where multiple services on a single server can be accessed by name and can be discovered with the namespace glob command.
There are two variants of the Globber interface defined in rpc/model.go: AllGlobber, and ChildrenGlobber. AllGlobber is the most flexible option, but also the most difficult to implement correctly. It is used by specialized applications like a mount table server.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://v.io/tutorials/management/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/management/overview/</guid>
      <description>Management is about running Vanadium applications remotely on heterogeneous devices.
The following tutorials build from the [basics tutorial] to demonstrate code and pre-built tools that implement and benefit from Vanadium application management.
  The Device Manager
Wherein you learn about running a server through the device manager.
  </description>
    </item>
    
    <item>
      <title>The Device Manager</title>
      <link>https://v.io/tutorials/management/device-manager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/management/device-manager/</guid>
      <description>Introduction In the basics tutorial, you ran the fortune server as a background process from the terminal.
In this tutorial, you&amp;rsquo;ll learn how to use the device manager to run your server remotely (however, the device manager you&amp;rsquo;ll be running as part of the tutorial is running on the same computer to keep things simple).
Credentials We&amp;rsquo;ll be using default credentials for all the commands and servers we start from the terminal.</description>
    </item>
    
    <item>
      <title>Internal Tutorial Checkup</title>
      <link>https://v.io/tutorials/checkup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/checkup/</guid>
      <description>A smoke test to see that VANADIUM_RELEASE is defined and provides access to crucial Vanadium file assets.
This isn&amp;rsquo;t meant to be an exhaustive test, just a quick check. It&amp;rsquo;s used in tests, tutorial preparation, etc.
function bad_vanadium() { echo &#39; Per https://vanadium.github.io/installation/, either export JIRI_ROOT={your installation directory} or do a fresh install.&#39;; exit 1; } [ -z &amp;quot;$VANADIUM_RELEASE&amp;quot; ] &amp;amp;&amp;amp; { echo &#39;The environment variable VANADIUM_RELEASE is not defined.&#39;; bad_vanadium; } [ -x &amp;quot;$VANADIUM_RELEASE/bin/principal&amp;quot; ] || { echo &#39;The file $VANADIUM_RELEASE/bin/principal does not exist or is not executable.</description>
    </item>
    
    <item>
      <title>Internal Tutorial Cleanup</title>
      <link>https://v.io/tutorials/cleanup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/cleanup/</guid>
      <description>Delete the tutorial workspace directory.
Might be used in tests, tutorial preparation, etc.
if [ -z &amp;quot;${V_TUT}&amp;quot; ]; then echo &amp;quot;V_TUT not defined, nothing to do.&amp;quot; else if [ -d &amp;quot;${V_TUT}&amp;quot; ]; then /bin/rm -rf $V_TUT echo &amp;quot;Removed $V_TUT&amp;quot; else echo &amp;quot;Not a directory: V_TUT=\&amp;quot;$V_TUT\&amp;quot;&amp;quot; fi fi </description>
    </item>
    
    <item>
      <title>Internal Tutorial Wipe Slate</title>
      <link>https://v.io/tutorials/wipe-slate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/wipe-slate/</guid>
      <description>Clear, but don&amp;rsquo;t delete, the tutorial workspace directory.
Might be used in tests, tutorial preparation, etc.
if [ -z &amp;quot;${V_TUT}&amp;quot; ]; then echo &amp;quot;V_TUT not defined, nothing to do.&amp;quot; else if [ -d &amp;quot;${V_TUT}&amp;quot; ]; then /bin/rm -rf $V_TUT/* echo &amp;quot;Removed contents of $V_TUT&amp;quot; else echo &amp;quot;Not a directory: V_TUT=\&amp;quot;$V_TUT\&amp;quot;&amp;quot; fi fi </description>
    </item>
    
    <item>
      <title>Tutorial Environment Setup</title>
      <link>https://v.io/tutorials/setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/setup/</guid>
      <description>You don&amp;rsquo;t need to read this, unless you were sent here with a suggestion to start a second tutorial terminal, likely to keep the output from multiple processes easier to read.
In addition to the $VANADIUM_RELEASE variable defined by installation, every terminal window used in a tutorial must run the environment definition script below.
If you follow the prerequisite instructions at the beginning of a tutorial, you&amp;rsquo;ll implicitly run the script on this page, and you&amp;rsquo;ll run commands from earlier tutorials that create the files needed by your current tutorial.</description>
    </item>
    
    <item>
      <title>Quick Installation</title>
      <link>https://v.io/tutorials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/</guid>
      <description>Vanadium can be installed on Linux or OS X.
To install Vanadium, download this script, then source it:
source ~/Downloads/vanadium-install.sh {{# helpers.hidden}} Please source this script:
source /dev/stdin &amp;lt;&amp;lt;&amp;lt; &amp;quot;$(curl -f -s https://v.io/sh/vanadium-install.sh)&amp;quot; {{/ helpers.hidden}}
This script checks for prerequisites, then attempts to install Vanadium. It takes about five minutes to run.
 If the script reports no errors, you&amp;rsquo;re ready to try the tutorials! If it complains, please follow the step-by-step instructions.</description>
    </item>
    
    <item>
      <title>Tutorial FAQ</title>
      <link>https://v.io/tutorials/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://v.io/tutorials/faq/</guid>
      <description>Do I need to know Go? No. The initial coding tutorials use short, unexotic blocks of Go that should be readable by anyone familiar with a language in the C family.
For Go specific tutorials, see golang.org.
Must the tutorials be done in order? No. Some tutorials assume familiarity with things covered in previous tutorials, and some literally depend on files created in previous tutorials but have instructions on how to get these without having to step through the tutorials that generate them.</description>
    </item>
    
  </channel>
</rss>
